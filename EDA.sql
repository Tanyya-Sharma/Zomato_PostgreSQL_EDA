-- EDA

select * from customers;
select * from restaurants;
select * from orders;
select * from riders;
select * from deliveries;

-- Check NULL values

SELECT COUNT(*) FROM customers
WHERE
    customer_name IS NULL
	OR
	reg_date IS NULL;

SELECT COUNT(*) FROM restaurants
WHERE
    restaurant_name IS NULL
	OR
	city IS NULL
	OR
	opening_hours IS NULL;

SELECT COUNT(*) FROM orders
WHERE
    order_item IS NULL
	OR
	order_date IS NULL
	OR
	order_time IS NULL
	OR
	order_status IS NULL
	OR
	total_amount IS NULL;

SELECT COUNT(*) FROM riders
WHERE
    rider_name IS NULL
	OR
	sign_up IS NULL;

-- ----------------------------------------
-- Analysis & Reports
-- ----------------------------------------

/*
Q1. Top 5 Most Frequently Ordered Dishes
Question:
Write a query to find the top 5 most frequently ordered dishes by the customer "Arjun Mehta" in
the last 1 year.

Q2. Popular Time Slots
Question:
Identify the time slots during which the most orders are placed, based on 2-hour intervals.

Q3. Order Value Analysis
Question:
Find the average order value (AOV) per customer who has placed more than 750 orders.
Return: customer_name, aov (average order value).

Q4. High-Value Customers
Question:
List the customers who have spent more than 100K in total on food orders.
Return: customer_name, customer_id.

Q5. Orders Without Delivery
Question:
Write a query to find orders that were placed but not delivered.
Return: restaurant_name, city, and the number of not delivered orders.

Q6. Restaurant Revenue Ranking

Question:
Rank restaurants by their total revenue from the last year.
Return: restaurant_name, total_revenue, and their rank within their city.

Q7. Most Popular Dish by City
Question:
Identify the most popular dish in each city based on the number of orders.

Q8. Customer Churn
Question:
Find customers who haven’t placed an order in 2024 but did in 2023.

Q9. Cancellation Rate Comparison
Question:
Calculate and compare the order cancellation rate for each restaurant between the current year
and the previous year.

Q10. Rider Average Delivery Time
Question:
Determine each rider's average delivery time.

Q11. Monthly Restaurant Growth Ratio
Question:
Calculate each restaurant's growth ratio based on the total number of delivered orders since its
joining.

Q12. Customer Segmentation
Question:
Segment customers into 'Gold' or 'Silver' groups based on their total spending compared to the
average order value (AOV). If a customer's total spending exceeds the AOV, label them as
'Gold'; otherwise, label them as 'Silver'.
Return: The total number of orders and total revenue for each segment.

Q13. Rider Monthly Earnings
Question:
Calculate each rider's total monthly earnings, assuming they earn 8% of the order amount.

Q14. Rider Ratings Analysis
Question:
Find the number of 5-star, 4-star, and 3-star ratings each rider has.
Riders receive ratings based on delivery time:
● 5-star: Delivered in less than 15 minutes
● 4-star: Delivered between 15 and 20 minutes
● 3-star: Delivered after 20 minutes

Q15. Order Frequency by Day
Question:
Analyze order frequency per day of the week and identify the peak day for each restaurant.

Q16. Customer Lifetime Value (CLV)
Question:
Calculate the total revenue generated by each customer over all their orders.

Q17. Monthly Sales Trends
Question:
Identify sales trends by comparing each month's total sales to the previous month.

Q18. Rider Efficiency
Question:
Evaluate rider efficiency by determining average delivery times and identifying those with the
lowest and highest averages.

Q19. Order Item Popularity
Question:
Track the popularity of specific order items over time and identify seasonal demand spikes.

Q20. City Revenue Ranking
Question:
Rank each city based on the total revenue for the last year (2023).
*/
-- -------------------------------------------------------------------------------------------

/* Q1. Top 5 Most Frequently Ordered Dishes
Question:
Write a query to find the top 5 most frequently ordered dishes by the customer "Arjun Mehta" in
the last 2 year. */
SELECT 
   customer_id, 
   customer_name, 
   dishes, 
   order_count 
FROM
(SELECT 
    c.customer_id, 
	c.customer_name,
	o.order_item dishes, 
	COUNT(*) order_count, 
	DENSE_RANK() OVER(ORDER BY COUNT(*) DESC) rank FROM customers c
JOIN orders o ON c.customer_id = o.customer_id
WHERE c.customer_name = 'Arjun Mehta' AND o.order_date >= CURRENT_DATE - INTERVAL '2 YEAR'
GROUP BY 1,2,3
ORDER BY 1,4 DESC
LIMIT 5) t1
WHERE rank <= 5;

/*Q2. Popular Time Slots
Question:
Identify the time slots during which the most orders are placed, based on 2-hour intervals.*/
SELECT CASE 
            WHEN EXTRACT(HOUR FROM order_time) BETWEEN 0 AND 1 THEN '00:00-02:00' 
			WHEN EXTRACT(HOUR FROM order_time) BETWEEN 2 AND 3 THEN '02:00-04:00'
			WHEN EXTRACT(HOUR FROM order_time) BETWEEN 4 AND 5 THEN '04:00-06:00'
			WHEN EXTRACT(HOUR FROM order_time) BETWEEN 6 AND 7 THEN '06:00-08:00'
			WHEN EXTRACT(HOUR FROM order_time) BETWEEN 8 AND 9 THEN '08:00-10:00'
			WHEN EXTRACT(HOUR FROM order_time) BETWEEN 10 AND 11 THEN '10:00-12:00'
			WHEN EXTRACT(HOUR FROM order_time) BETWEEN 12 AND 13 THEN '12:00-14:00'
			WHEN EXTRACT(HOUR FROM order_time) BETWEEN 14 AND 15 THEN '14:00-16:00'
			WHEN EXTRACT(HOUR FROM order_time) BETWEEN 16 AND 17 THEN '16:00-18:00'
			WHEN EXTRACT(HOUR FROM order_time) BETWEEN 18 AND 19 THEN '18:00-20:00'
			WHEN EXTRACT(HOUR FROM order_time) BETWEEN 20 AND 21 THEN '20:00-22:00'
			WHEN EXTRACT(HOUR FROM order_time) BETWEEN 22 AND 23 THEN '22:00-00:00'
		END time_slot, 
		COUNT(*) order_count 
FROM orders 
GROUP BY 1
ORDER BY 2 DESC;

/* Q3. Order Value Analysis
Question:
Find the average order value (AOV) per customer who has placed more than 750 orders.
Return: customer_name, aov (average order value). */
SELECT 
   c.customer_name, 
   ROUND(AVG(total_amount)::numeric,2) avg_order_value 
FROM customers c 
JOIN orders o ON c.customer_id = o.customer_id
GROUP BY 1
HAVING COUNT(order_id) >= 750;

/* Q4. High-Value Customers
Question:
List the customers who have spent more than 100K in total on food orders.
Return: customer_name, customer_id. */
WITH High_Value_Customers AS
(SELECT c.customer_id, 
    c.customer_name, 
	SUM(total_amount) AS total_amt_spent 
FROM orders o
JOIN customers c ON c.customer_id = o.customer_id
GROUP BY 1
HAVING SUM(total_amount) >= 100000
ORDER BY 1)
SELECT 
   customer_id, 
   customer_name 
FROM High_Value_Customers;

/* Q5. Orders Without Delivery
Question:
Write a query to find orders that were placed but not delivered.
Return: restaurant_name, city, and the number of not delivered orders. */
-- Approach 1
SELECT 
	r.restaurant_name,
	COUNT(o.order_id) as cnt_not_delivered_orders
FROM orders as o
LEFT JOIN 
restaurants as r
ON r.restaurant_id = o.restaurant_id
LEFT JOIN
deliveries as d
ON d.order_id = o.order_id
WHERE d.delivery_id IS NULL
GROUP BY 1
ORDER BY 2 DESC;

-- Approach 2
SELECT 
	r.restaurant_name,
	COUNT(*)
FROM orders as o
LEFT JOIN 
restaurants as r
ON r.restaurant_id = o.restaurant_id
WHERE 
	o.order_id NOT IN (SELECT order_id FROM deliveries)
GROUP BY 1
ORDER BY 2 DESC;

/* Q6. Restaurant Revenue Ranking
Question:
Rank restaurants by their total revenue from the last 2 year.
Return: restaurant_name, total_revenue, and their rank within their city. */
WITH ranking_table
AS
(
	SELECT 
		r.city,
		r.restaurant_name,
		SUM(o.total_amount) as revenue,
		RANK() OVER(PARTITION BY r.city ORDER BY SUM(o.total_amount) DESC) as rank
	FROM orders as o
	JOIN 
	restaurants as r
	ON r.restaurant_id = o.restaurant_id
	WHERE o.order_date >= CURRENT_DATE - INTERVAL '2 year'
	GROUP BY 1, 2
)
SELECT 
	*
FROM ranking_table
WHERE rank = 1;

/* Q7. Most Popular Dish by City
Question:
Identify the most popular dish in each city based on the number of orders. */
SELECT * FROM
(SELECT order_item most_popular_dish, r.city, COUNT(order_id) order_count,
DENSE_RANK() OVER (PARTITION BY r.city ORDER BY COUNT(order_id) DESC) rank FROM orders o 
JOIN restaurants r ON r.restaurant_id = o.restaurant_id
GROUP BY 1,2) t1
WHERE rank = 1;

/* Q8. Customer Churn
Question:
Find customers who haven’t placed an order in 2024 but did in 2023. */
SELECT DISTINCT c.customer_id, c.customer_name
FROM customers c
WHERE c.customer_id IN (
    SELECT customer_id
    FROM orders
    WHERE EXTRACT(YEAR FROM order_date) = 2023)
AND c.customer_id NOT IN (
    SELECT customer_id
    FROM orders
    WHERE EXTRACT(YEAR FROM order_date) = 2024);

/* Q9. Cancellation Rate Comparison
Question:
Calculate and compare the order cancellation rate for each restaurant between the current year
and the previous year. */
WITH cancel_ratio_23 AS (
    SELECT 
	   o.restaurant_id, 
	   COUNT(o.order_id) total_orders, 
	   COUNT(CASE WHEN d.delivery_id IS NULL THEN 1 END) not_delivered
	 FROM orders o
	 LEFT JOIN deliveries d 
	 ON o.order_id = d.order_id
	 WHERE EXTRACT(YEAR FROM o.order_date) = 2023
	 GROUP BY 1
),
cancel_ratio_24 AS (
    SELECT 
	   o.restaurant_id,
	    COUNT(o.order_id) total_orders, 
	   COUNT(CASE WHEN d.delivery_id IS NULL THEN 1 END) not_delivered
	 FROM orders o
	 LEFT JOIN deliveries d 
	 ON o.order_id = d.order_id
	 WHERE EXTRACT(YEAR FROM o.order_date) = 2024
	 GROUP BY 1
),
last_year_data AS (
    SELECT 
	   restaurant_id,
	   total_orders,
	   not_delivered,
	   ROUND((not_delivered::numeric / total_orders::numeric) * 100, 2) cancel_ratio
	 FROM cancel_ratio_23
),
current_year_data AS (
    SELECT 
	   restaurant_id,
	   total_orders,
	   not_delivered,
	   ROUND((not_delivered::numeric / total_orders::numeric) * 100, 2) cancel_ratio
	 FROM cancel_ratio_24
)
SELECT 
   c.restaurant_id restaurant_id,
   c.cancel_ratio current_year_cancel_ratio,
   l.cancel_ratio last_year_cancel_ratio
FROM current_year_data c
JOIN last_year_data l
ON c.restaurant_id = l.restaurant_id;

/* Q10. Rider Average Delivery Time
Question:
Determine each rider's average delivery time. */
WITH delivery_durations AS (
SELECT 
   o.order_id, 
   o.order_time,
   d.rider_id, 
   d.delivery_time, 
   d.delivery_time - o.order_time time_diff, 
   EXTRACT(EPOCH FROM (d.delivery_time - o.order_time + 
   CASE 
      WHEN d.delivery_time < o.order_time 
	  THEN INTERVAL '1 day' 
	  ELSE INTERVAL '0 day' 
	END))/60 time_diff_in_mins FROM orders o
JOIN deliveries d ON o.order_id = d.order_id
WHERE delivery_status = 'Delivered'
)
SELECT 
   rider_id,
   ROUND(AVG(time_diff_in_mins),2) avg_delivery_time
FROM delivery_durations
GROUP BY 1
ORDER BY 1;

/* Q11. Monthly Restaurant Growth Ratio
Question:
Calculate each restaurant's growth ratio based on the total number of delivered orders since its
joining. */
WITH growth_ratio AS (
SELECT 
   o.restaurant_id, 
   TO_CHAR(o.order_date, 'mm-yy') as month, 
   COUNT(o.order_id) curr_month_orders, 
   LAG(COUNT(o.order_id),1) OVER(PARTITION BY o.restaurant_id ORDER BY TO_CHAR(o.order_date, 'mm-yy')) prev_month_orders 
FROM orders o
JOIN deliveries d ON o.order_id = d.order_id
WHERE d.delivery_status = 'Delivered'
GROUP BY 1,2
ORDER BY 1,2
)
SELECT 
    restaurant_id, 
	month, 
	prev_month_orders, 
	curr_month_orders,
	ROUND((curr_month_orders::numeric - prev_month_orders::numeric)/prev_month_orders * 100,2) monthly_growth_ratio 
FROM growth_ratio;

-- (curr-prev)/prev*100

/* Q12. Customer Segmentation
Question:
Segment customers into 'Gold' or 'Silver' groups based on their total spending compared to the
average order value (AOV). If a customer's total spending exceeds the AOV, label them as
'Gold'; otherwise, label them as 'Silver'.
Return: The total number of orders and total revenue for each segment. */
-- get total_revenue, AOV
-- Use CASE WHEN approach for segmentation
-- Group by customer_segmentation at the end 
SELECT 
   customer_segmentation, 
   SUM(total_orders) total_orders,
   SUM( total_spendings) total_revenue
FROM (
SELECT 
   customer_id, 
   COUNT(*) total_orders,
   SUM(total_amount) total_spendings,
   CASE 
     WHEN SUM(total_amount) > (SELECT AVG(total_amount) FROM orders) THEN 'Gold' 
	 ELSE 'Silver'
	END customer_segmentation
FROM orders
GROUP BY 1) t1
GROUP BY 1;

/* Q13. Rider Monthly Earnings
Question:
Calculate each rider's total monthly earnings, assuming they earn 8% of the order amount. */
SELECT 
	d.rider_id,
	TO_CHAR(o.order_date, 'mm-yy') as month,
	SUM(total_amount) as revenue,
	SUM(total_amount)* 0.08 as riders_earning
FROM orders as o
JOIN deliveries as d
ON o.order_id = d.order_id
GROUP BY 1, 2
ORDER BY 1, 2;

/* Q14. Rider Ratings Analysis
Question:
Find the number of 5-star, 4-star, and 3-star ratings each rider has.
Riders receive ratings based on delivery time:
● 5-star: Delivered in less than 15 minutes
● 4-star: Delivered between 15 and 20 minutes
● 3-star: Delivered after 20 minutes */
-- Convert timestamp to mins
-- Use CASE WHEN Approach 
WITH delivery_durations AS (
SELECT o.order_id, o.order_time, d.rider_id, d.delivery_time,
EXTRACT(EPOCH FROM (d.delivery_time - o.order_time + 
  CASE 
     WHEN d.delivery_time < o.order_time 
     THEN INTERVAL '1 day'
     ELSE INTERVAL '0 day' 
  END))/60 time_diff_in_mins
FROM orders o
JOIN deliveries d ON o.order_id = d.order_id
WHERE delivery_status = 'Delivered'
),
categorised_ratings AS (
SELECT 
    rider_id, 
	CASE 
	   WHEN time_diff_in_mins < 15 
	   THEN '5-star' 
	   WHEN time_diff_in_mins BETWEEN 15 AND 20
	   THEN '4-star'
	   ELSE '3-star'
	END rider_rating
FROM delivery_durations
)
SELECT 
    rider_id,
    rider_rating,
    COUNT(*) AS rating_count
FROM categorised_ratings
GROUP BY 1,2
ORDER BY 1,2;

/* Q15. Order Frequency by Day
Question:
Analyze order frequency per day of the week and identify the peak day for each restaurant. */
WITH daywise_freq AS (
    SELECT 
       restaurant_id,
       EXTRACT(DOW FROM order_date) AS day_of_week,
       COUNT(*) AS order_freq
    FROM orders
    GROUP BY restaurant_id, day_of_week
),
peak_days AS (
    SELECT 
	   *,
	   MAX(order_freq) OVER (PARTITION BY restaurant_id) AS max_freq
    FROM daywise_freq
)
SELECT 
    restaurant_id,
    day_of_week AS peak_day,
    order_freq
FROM peak_days
WHERE order_freq = max_freq
ORDER BY restaurant_id;

/* Q16. Customer Lifetime Value (CLV)
Question:
Calculate the total revenue generated by each customer over all their orders. */
SELECT 
	o.customer_id,
	c.customer_name,
	SUM(o.total_amount) as CLV
FROM orders as o
JOIN customers as c
ON o.customer_id = c.customer_id
GROUP BY 1, 2;

/* Q17. Monthly Sales Trends
Question:
Identify sales trends by comparing each month's total sales to the previous month. */
SELECT 
   EXTRACT(YEAR FROM order_date) order_year,
   EXTRACT(MONTH FROM order_date) order_month,
   SUM(total_amount) total_sales,
   LAG(SUM(total_amount),1) OVER(ORDER BY 
     EXTRACT(YEAR FROM order_date), 
     EXTRACT(MONTH FROM order_date)) prev_month
FROM orders
GROUP BY 1,2;
----------------------------------------------------
         --OR--
----------------------------------------------------
WITH monthly_sales AS (
    SELECT 
        DATE_TRUNC('month', order_date) AS month,
        SUM(total_amount) AS total_sales
    FROM orders
    GROUP BY month
)
SELECT 
    month,
    total_sales,
    LAG(total_sales) OVER (ORDER BY month) AS prev_month_sales,
    (total_sales - LAG(total_sales) OVER (ORDER BY month)) AS sales_diff,
    ROUND(
        (total_sales::numeric - LAG(total_sales) OVER (ORDER BY month)::numeric * 100) 
        / NULLIF(LAG(total_sales) OVER (ORDER BY month)::numeric, 0), 
        2
    ) AS growth_rate
FROM monthly_sales
ORDER BY month;

/* Q18. Rider Efficiency
Question:
Evaluate rider efficiency by determining average delivery times and identifying those with the
lowest and highest averages. */
WITH delivery_durations AS (
SELECT 
   d.rider_id, 
   EXTRACT(EPOCH FROM (d.delivery_time - o.order_time + 
   CASE 
      WHEN d.delivery_time < o.order_time 
	  THEN INTERVAL '1 day' 
	  ELSE INTERVAL '0 day' 
	END))/60 delivery_durations 
FROM orders o
JOIN deliveries d ON o.order_id = d.order_id
WHERE delivery_status = 'Delivered'
),
average_delivery_time AS (
SELECT 
   rider_id,
   ROUND(AVG(delivery_durations),2) avg_delivery_time
FROM delivery_durations
GROUP BY 1
),
extremes AS (
SELECT 
   MAX(avg_delivery_time) max_time,
   MIN(avg_delivery_time) min_time
FROM average_delivery_time
)
SELECT 
    a.rider_id,
    a.avg_delivery_time,
    CASE 
        WHEN a.avg_delivery_time = e.min_time THEN 'Most Efficient'
        WHEN a.avg_delivery_time = e.max_time THEN 'Least Efficient'
        ELSE 'Average'
    END AS efficiency_level
FROM average_delivery_time a
CROSS JOIN extremes e
ORDER BY 2;

/* Q19. Order Item Popularity
Question:
Track the popularity of specific order items over time and identify seasonal demand spikes. */
SELECT 
    order_item,
    seasons,
	COUNT(order_id) total_orders
FROM (
SELECT *,
   order_date,
   EXTRACT(MONTH FROM order_date) as month,
   CASE
      WHEN EXTRACT(MONTH FROM order_date) BETWEEN 4 AND 7
	  THEN 'Spring'
	  WHEN  EXTRACT(MONTH FROM order_date) > 6 AND EXTRACT(MONTH FROM order_date) < 9
	  THEN 'Summer'
	  ELSE 'Winter'
	END seasons
FROM orders) as t1
GROUP BY 1,2
ORDER BY 1, 3 DESC;

/* Q20. City Revenue Ranking
Question:
Rank each city based on the total revenue for the last year (2023). */
SELECT 
   r.city,
   SUM(total_amount) total_revenue, 
   RANK() OVER(ORDER BY SUM(total_amount) DESC) city_rank
FROM orders o
JOIN restaurants r ON o.restaurant_id = r.restaurant_id
GROUP BY 1;

-- END OF REPORTS --